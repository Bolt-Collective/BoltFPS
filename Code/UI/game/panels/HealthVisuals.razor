@using Sandbox;

@inherits PanelComponent

@namespace Seekers

<root>
	@foreach (var splatter in Splatters)
	{
		var baseAlpha = OpacityCurve.Evaluate(1- Health );
		var alpha = baseAlpha + (1 - (Time.Now - splatter.time) / FadeTime).Clamp(0,1) * (1-baseAlpha);
		var position = (splatter.position / 100) * new Vector2(1080 * Screen.Aspect, 1080);

		<img src=@splatter.texture style="bottom: @(position.y-250)px; left: @(position.x-250)px; opacity: @alpha; transform: rotate(@(splatter.rotation)deg);"/>
	}
	@foreach (var splatter in DeSplatters)
	{
		var elapsed = Time.Now - splatter.time;
		var t = (elapsed / splatter.speed).Clamp(0, 1);
		var alpha = splatter.startAlpha * (1 - t);

		var position = (splatter.position / 100) * new Vector2(1080 * Screen.Aspect, 1080);

		<img src=@splatter.texture style="bottom: @(position.y-250)px; left: @(position.x-250)px; opacity: @alpha; transform: rotate(@(splatter.rotation)deg);" />
	}
</root>

@code
{
	[Property, ImageAssetPath] private List<string> BloodTextures { get; set; }
	[Property] private Curve SplatterCurve { get; set; }
	[Property] private Curve SatuationCurve { get; set; }
	[Property] private Curve OpacityCurve { get; set; }
	[Property] private float FadeTime { get; set; } = 0.1f;
	[Property] private RangedFloat FadeOutTime { get; set; } = new RangedFloat(0.2f, 0.5f);

	private float Health;

	ColorAdjustments _colorAdjustments;
	ColorAdjustments ColorAdjustments 
	{
		get{
			if (!_colorAdjustments.IsValid())
				_colorAdjustments = Pawn.Local.Controller.Camera.GetComponent<ColorAdjustments>();
			return _colorAdjustments;
		}
	}

	private List<(string texture, Vector2 position, float rotation, float time)> Splatters { get; set; } = new();

	private List<(string texture, Vector2 position, float rotation, float time, float startAlpha, float speed)> DeSplatters { get; set; } = new();
	protected override void OnUpdate()
	{
		var player = Pawn.Local;

		if ( !player.IsValid() )
			return;

		if ( !player.Controller.IsValid() )
			return;

		Health = player.HealthComponent.Health / player.HealthComponent.MaxHealth;

		if(ColorAdjustments.IsValid())
		{
			ColorAdjustments.Saturation = SatuationCurve.Evaluate( 1-Health );
		}

		int splatterCount = MathX.FloorToInt( SplatterCurve.Evaluate(1- Health));

		if ( splatterCount > Splatters?.Count )
		{
			for ( int i = 0; i < splatterCount - Splatters?.Count; i++ )
				AddSplatter();
		}
		else if (splatterCount < Splatters?.Count)
		{
			var removed = Splatters?.GetRange(0, Splatters.Count - splatterCount);
			Splatters?.RemoveRange(0, Splatters.Count - splatterCount);

			foreach (var r in removed)
			{
				var baseAlpha = OpacityCurve.Evaluate(1 - Health);
				var currentAlpha = baseAlpha + (1 - (Time.Now - r.time) / FadeTime).Clamp(0, 1) * (1 - baseAlpha);
				DeSplatters?.Add((r.texture, r.position, r.rotation, Time.Now, currentAlpha, FadeOutTime.GetValue()));
			}
		}

		foreach (var splatter in new List<(string texture, Vector2 position, float rotation, float time, float startAlpha, float speed)>(DeSplatters))
		{
			if ( Time.Now - splatter.time > FadeOutTime.Max * 1.5f)
			{
				DeSplatters.Remove(splatter);
			}
		}
	}

	[Button]
	void AddSplatter()
	{
		var texture = BloodTextures[Game.Random.Next(0,BloodTextures.Count)];
		Splatters?.Add( (texture, GetRandomScreenEdgePoint(), Game.Random.Next(0,360), Time.Now) );
	}

	Vector2 GetRandomScreenEdgePoint()
	{
		int screenWidth = 100;
		int screenHeight = 100;

		int edge = Game.Random.Next( 0, 4 );
		switch ( edge )
		{
			case 0:
				return new Vector2( Game.Random.Next( 0, screenWidth ), screenHeight );
			case 1:
				return new Vector2( Game.Random.Next( 0, screenWidth ), 0 );
			case 2:
				return new Vector2( 0, Game.Random.Next( 0, screenHeight ) );
			case 3:
				return new Vector2( screenWidth, Game.Random.Next( 0, screenHeight ) );
			default:
				return Vector2.Zero;
		}
	}


	protected override int BuildHash()
	{
		return HashCode.Combine(Time.Now);
	}
}
