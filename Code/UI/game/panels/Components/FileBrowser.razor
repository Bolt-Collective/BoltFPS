@using System.IO
@using Sandbox;
@using Sandbox.UI;

@namespace Seekers

@inherits Panel
@implements IContextMenuProvider

<root class="file-browser">
	<div class="file-tree" onmousedown="@( e => HandleNodeMouseDown( e, TargetFolder, true ) )">
		@foreach ( var folder in GetFoldersFromDirectory( TargetFolder ) )
		{
			<div class="node folder"
			     style="margin-left:@( GetDepth( folder ) * 16 )px"
			     onmousedown="@( e => HandleNodeMouseDown( e, folder, true ) )">
				<img src="icons/menu/Folder.svg?w=20&h=20"/>
				<p>@GetLastSegment( folder )</p>
			</div>

			@foreach ( var file in GetFilesFromDirectory( folder, recursive: false ) )
			{
				<div class="node file"
				     style="margin-left:@( GetDepth( folder ) * 16 + 16 )px"
				     onmousedown="@( e => HandleNodeMouseDown( e, Path.Combine( folder, Path.GetFileName( file ) ), false ) )">
					<img src="icons/menu/Stack.svg?w=64&h=64"/>
					<p>@Path.GetFileName( file )</p>
				</div>
			}
		}

		@foreach ( var file in GetFilesFromDirectory( string.Empty, recursive: false ) )
		{
			<div class="node file"
			     style="margin-left:16px"
			     onmousedown="@( e => HandleNodeMouseDown( e, file, false ) )">
				<img src="icons/menu/Stack.svg?w=64&h=64"/>
				<p>@Path.GetFileName( file )</p>
			</div>
		}

		@if ( CreatingANode )
		{
			<div class="create-node-prompt">
				<label>@( CreatingFolder ? "New Folder Name:" : "New File Name:" )</label>
				<TextEntry Value:bind="@NewNodeName"/>
				<button onclick="@OnCreateNodeConfirm">Create</button>
				<button onclick="@OnCreateNodeCancel">Cancel</button>
			</div>
		}
	</div>
</root>

@code
{
	/// <summary>
	/// What folder to display files from in Data
	/// </summary>
	public string TargetFolder { get; private set; }

	Panel folderPanel;
	Panel filePanel;

	bool CreatingANode = false;
	bool CreatingFolder = false;
	string NewNodeName = "";
	string CreationBasePath = "";

	public FileBrowser( string targetFolder )
	{
		if ( string.IsNullOrWhiteSpace( targetFolder ) )
			return;

		TargetFolder = targetFolder;

		if ( !FileSystem.Data.DirectoryExists( targetFolder ) )
		{
			FileSystem.Data.CreateDirectory( targetFolder );
		}
	}

	public List<string> GetFoldersFromDirectory( string directory )
	{
		var dir = FileSystem.Data.FindDirectory( directory, recursive: true );

		var dirList = dir.ToList();
		dirList.Sort();

		return dirList;
	}

	public List<string> GetFilesFromDirectory( string folder, bool recursive )
	{
		var basePath = string.IsNullOrWhiteSpace( folder )
			? TargetFolder
			: Path.Combine( TargetFolder, folder );

		var files = FileSystem.Data.FindFile( basePath, recursive: recursive );

		var fileList = files.ToList();
		fileList.Sort();

		return fileList;
	}

	void CreateFile( string name, string data = "" )
	{
		if ( string.IsNullOrWhiteSpace( name ) )
			return;

		var path = Path.Combine( TargetFolder, name );
		if ( FileSystem.Data.FileExists( path ) )
			return;

		FileSystem.Data.WriteAllText( path, data );
	}

	void CreateFolder( string name )
	{
		if ( string.IsNullOrWhiteSpace( name ) )
			return;

		var path = Path.Combine( TargetFolder, name );
		if ( FileSystem.Data.DirectoryExists( path ) )
			return;

		FileSystem.Data.CreateDirectory( path );
	}

	private static int GetDepth( string relativePath )
	{
		if ( string.IsNullOrWhiteSpace( relativePath ) )
			return 0;

		var norm = relativePath.Replace( '\\', '/' ).Trim( '/' );
		if ( string.IsNullOrEmpty( norm ) )
			return 0;

		return norm.Count( c => c == '/' );
	}

	private static string GetLastSegment( string relativePath )
	{
		if ( string.IsNullOrWhiteSpace( relativePath ) )
			return string.Empty;

		var norm = relativePath.Replace( '\\', '/' ).TrimEnd( '/' );
		var i = norm.LastIndexOf( '/' );
		return i >= 0 ? norm[(i + 1)..] : norm;
	}

	private void HandleNodeMouseDown( PanelEvent e, string path, bool isFolder )
	{
		MousePanelEvent me = e as MousePanelEvent;
		if ( me.MouseButton == MouseButtons.Right )
		{
			Log.Info( me.MouseButton );
			me.StopPropagation();

			var entries = GetContextMenuItems( path, isFolder );
			var screenPos = Mouse.Position;

			ContextMenu.Open( FindRootPanel(), screenPos, entries );
		}
	}

	public List<ContextMenu.Entry> GetContextMenuItems( string path, bool isFolder )
	{
		var entries = new List<ContextMenu.Entry>();

		if ( isFolder )
		{
			entries.Add( new("New File", () =>
			{
				CreatingANode = true;
				CreatingFolder = false;
				NewNodeName = "";
				CreationBasePath = path;
				StateHasChanged();
			}) );
			entries.Add( new("New Folder", () =>
			{
				CreatingANode = true;
				CreatingFolder = true;
				NewNodeName = "";
				CreationBasePath = path;
				StateHasChanged();
			}) );
			entries.Add( new("Delete", () =>
			{
				var fullPath = Path.Combine( TargetFolder, path );
				Log.Info( fullPath );
				if ( FileSystem.Data.DirectoryExists( fullPath ) )
					FileSystem.Data.DeleteDirectory( fullPath, recursive: true );
			}) );
		}
		else
		{
			entries.Add( new("Rename", () => Log.Info( $"Rename {path}" )) );
			entries.Add( new("Delete", () =>
			{
				var fullPath = Path.Combine( TargetFolder, path );
				Log.Info( fullPath );
				if ( FileSystem.Data.FileExists( fullPath ) )
					FileSystem.Data.DeleteFile( fullPath );
			}) );
		}

		return entries;
	}

	void OnCreateNodeConfirm()
	{
		if ( !string.IsNullOrWhiteSpace( NewNodeName ) )
		{
			string basePath;
			if ( string.IsNullOrWhiteSpace( CreationBasePath ) )
			{
				basePath = TargetFolder;
			}
			else
			{
				basePath = Path.Combine( TargetFolder, CreationBasePath );
			}

			if ( CreatingFolder )
			{
				var folderPath = Path.Combine( basePath, NewNodeName );
				if ( !FileSystem.Data.DirectoryExists( folderPath ) )
					FileSystem.Data.CreateDirectory( folderPath );
			}
			else
			{
				var filePath = Path.Combine( basePath, NewNodeName );
				if ( !FileSystem.Data.FileExists( filePath ) )
					FileSystem.Data.WriteAllText( filePath, "" );
			}

			CreatingANode = false;
			NewNodeName = "";
			CreationBasePath = "";
			StateHasChanged();
		}
	}

	void OnCreateNodeCancel()
	{
		CreatingANode = false;
		NewNodeName = "";
		CreationBasePath = "";
		StateHasChanged();
	}

	protected override int BuildHash()
	{
		return HashCode.Combine( GetFoldersFromDirectory( TargetFolder ), CreatingANode );
	}
}
